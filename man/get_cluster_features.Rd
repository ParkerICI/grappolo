% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/features.R
\name{get_cluster_features}
\alias{get_cluster_features}
\title{Calculate cluster features for model building}
\usage{
get_cluster_features(tab, metadata.tab, features.names, out.format = "table",
  predictors = NULL, endpoint.grouping = NULL)
}
\arguments{
\item{tab}{A \code{data.frame} representing clustering results, as produced by \code{cluster_data} (see Details)}

\item{metadata.tab}{A \code{data.frame} containing sample metadata (see Details)}

\item{features.names}{The name of the features in \code{tab} that are to be included in the output. These names correspond to the portion before the \code{@}
in \code{names(tab)}}

\item{out.format}{The format of the return value, see below for detail}

\item{predictors}{Only used if \code{out.format == "tidy"}. Columns in \code{metadata.tab} that identify predictors.}

\item{endpoint.grouping}{Only used if \code{out.format == "tidy"}. Columns in \code{metadata.tab} that identify the grouping of the response variable
(see Details). The combination of \code{predictors} and \code{endpoint.grouping} must uniquely identify every row in \code{metadata.tab}.
The function will throw an error if this is not the case.}
}
\value{
Returns a data frame whose format depends on the value of the \code{format} parameter
  \itemize{
    \item{table}: each row corresponds to a combination of the levels of the variables specified in \code{endpoint.grouping}, and the columns are
    cluster features, which are combinations of the levels of the \code{predictors} for each feature specified in \code{features.names}
    \item{tidy}: there is a single numeric column, and all the other columns represent variables whose combinations uniquely identify each observation (i.e. each row)
  }
}
\description{
This function takes a clustering result and a table of sample metadata, and calculates cluster features to be used for model building
}
\details{
This function is designed to work with the results of \code{cluster_data}. These results contain sample-level values for size of the clusters
and channel intensities. A column such as \code{foo@sample1} identifies the \code{sample1}-specific value of variable \code{foo} for each cluster. The
\code{metadata.tab} must contain a \code{file} column, which matches the names of the samples in \code{tab} (i.e. the part after the \code{@}, "sample1" in the
above example). The rest of the columns in \code{metadata.tab} represent file-level metadata, which is used to identify the data corresponding to
a given combination of predictors (see below)
An example will help clarify the working of this function. Suppose you have collected data from multiple patients at multiple timepoints and under multiple
stimulation conditions.
In this case the \code{metadata.tab} would look like this
\itemize{
  \item{\code{file}}{The names of the data files that contain data for each sample. These must match the names in the clustering results (see above)}
  \item{\code{timepoint}}{The timepoint information}
  \item{\code{condition}}{The stimulation condition}
  \item{\code{subject}}{The subjet each file was derived from}
}
Let's assume a few different scenarios.
\enumerate{
  \item You have subject level information (e.g. "responder" vs "non-responder") and you want to predict whether any combination of the \code{timepoint} and
        \code{condition} information predicts this outcome. In this case you would call the function with \code{predictors = c("condition", "timepoint")} and
        \code{endpoint.grouping = "sample"}. The features in the resulting output would look like \code{cluster_1_feature1_condition_timepoint}
  \item You have subject and timepoint level information, and you want to see if any of the stimulation conditions predicts it. In this case you would call
        the function with \code{predictors = c("condition")} and \code{endpoint.grouping = c("sample", "timepoint")}. The features in the resulting output
        would look like \code{cluster_1_feature1_condition}
}
}
